// Generated by CoffeeScript 1.3.3
(function() {
  var events, fs, map, match, path, util, watch, watchDir, watchFiles,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  util = require('util');

  path = require('path');

  events = require('events');

  map = {};

  exports.extentions = ['html', 'htm', 'css', 'js', 'png', 'gif', 'jpg', 'php', 'php5', 'py', 'rb', 'erb'];

  exports.watch = function(dir_name, options, callback) {
    var em, existsFuc, monitor, _ref;
    if (!callback) {
      if (callback == null) {
        callback = options != null ? options : function() {};
      }
      options = {};
    }
    if ((_ref = options.exts) == null) {
      options.exts = exports.extentions;
    }
    if (!options.ignore) {
      options.ignore = function(file) {
        return /^\./.test(file);
      };
    }
    em = new events.EventEmitter();
    monitor = function(err, file, event) {
      if (err) {
        return em.emit('error', err);
      } else {
        return em.emit(event, file);
      }
    };
    existsFuc = fs.existsSync ? fs.existsSync : path.existsSync;
    if (!existsFuc) {
      console.log("" + dir_name + " is not exists");
      return;
    }
    watch(dir_name, options, monitor);
    console.log("Start watch " + dir_name);
    callback(em);
    return em;
  };

  match = function(file, extentions) {
    return extentions.some(function(ele, index, array) {
      return file.slice(file.length - ele.length) === ele;
    });
  };

  watchFiles = function(dir, files, options, callback) {
    var filename, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      filename = files[_i];
      if (!options.ignore(filename)) {
        _results.push((function(filename) {
          var file;
          file = "" + dir + "/" + filename;
          return fs.stat(file, function(err, stats) {
            if (err) {
              if (err.code !== 'ENOENT') {
                return callback(err);
              }
            } else {
              if (stats.isDirectory()) {
                watchDir(file, options, callback);
              } else if (stats.isFile() && match(file, options.exts)) {
                return fs.watchFile(file, function(curr, prev) {
                  if (curr.nlink === 0) {
                    callback(null, file, 'delete');
                    fs.unwatchFile(file);
                    return;
                  }
                  if (curr.nlink !== 0 && curr.mtime.getTime() === prev.mtime.getTime()) {
                    return;
                  }
                  return callback(null, file, 'change');
                });
              }
            }
          });
        })(filename));
      }
    }
    return _results;
  };

  watchDir = function(dir, options, callback) {
    var walk;
    walk = function() {
      return fs.readdir(dir, function(err, files) {
        var newFiles;
        if (err) {
          return callback(err);
        }
        if (!map[dir]) {
          map[dir] = files;
        } else {
          newFiles = files.filter(function(file) {
            if (__indexOf.call(map[dir], file) < 0 && match(file, options.exts)) {
              callback(null, file, 'create');
              return file;
            }
          });
          map[dir] = files;
          files = newFiles != null ? newFiles : [];
        }
        return watchFiles(dir, files, options, callback);
      });
    };
    fs.watchFile(dir, function(curr, prev) {
      if (curr.nlink === 0) {
        callback(null, dir, 'delete');
        fs.unwatchFile(dir);
      }
      if (curr.size > prev.size) {
        return walk();
      }
    });
    return walk();
  };

  watch = function(dir_name, options, callback) {
    return fs.stat(dir_name, function(err, stats) {
      if (err) {
        util.error("Error for reading " + dir_name);
        return callback(err);
      } else {
        if (stats.isDirectory()) {
          return watchDir(dir_name, options, callback);
        } else if (stats.isFile()) {
          return watchFiles(path.dirname(dir_name), [dir_name], options, callback);
        }
      }
    });
  };

}).call(this);
